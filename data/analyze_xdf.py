import pyxdf
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, butter, filtfilt
import sys

def load_ppg_from_xdf(filename):
    """
    Load PPG data from an XDF file generated by the OmniBuds LSL stream.
    
    :param filename: Path to the XDF file
    :return: time_stamps (array), ppg_data (2D array: samples x channels [Green, Red, IR])
    """
    data, header = pyxdf.load_xdf(filename)
    
    for stream in data:
        if stream['info']['name'][0] == 'OmniBuds_PPG':
            time_stamps = stream['time_stamps']
            ppg_data = stream['time_series']  # Assuming shape: (n_samples, 3)
            print(f"Loaded PPG stream: {ppg_data.shape[0]} samples at ~{stream['info']['nominal_srate'][0]} Hz")
            return time_stamps, ppg_data
    
    raise ValueError("No 'OmniBuds_PPG' stream found in the XDF file.")

def bandpass_filter(data, lowcut=0.5, highcut=5.0, fs=100, order=3):
    """
    Apply bandpass filter to PPG signal (Butterworth).
    
    :param data: 1D array of PPG signal
    :param lowcut: Low cutoff frequency (Hz)
    :param highcut: High cutoff frequency (Hz)
    :param fs: Sampling frequency (Hz)
    :param order: Filter order
    :return: Filtered signal
    """
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return filtfilt(b, a, data)

def estimate_heart_rate(ppg_signal, fs=100, min_distance=0.4):
    """
    Estimate heart rate from PPG signal by detecting peaks.
    
    :param ppg_signal: 1D filtered PPG signal (inverted if needed for peak detection)
    :param fs: Sampling frequency (Hz)
    :param min_distance: Minimum distance between peaks in seconds
    :return: heart_rate (bpm), peak_indices
    """
    # Invert signal if needed (PPG peaks are often downward, but we detect upward peaks)
    ppg_signal = -ppg_signal  # Assuming raw PPG decreases on pulse
    
    min_dist_samples = int(min_distance * fs)
    peaks, _ = find_peaks(ppg_signal, distance=min_dist_samples)
    
    if len(peaks) < 2:
        return None, None
    
    # Calculate average RR interval in seconds
    rr_intervals = np.diff(peaks) / fs
    avg_rr = np.mean(rr_intervals)
    heart_rate = 60 / avg_rr
    return heart_rate, peaks

def analyze_ppg(filename, plot=True):
    """
    Analyze PPG data from XDF: filter, estimate HR for all channels, and optionally plot.
    
    :param filename: Path to XDF file
    :param plot: Whether to generate plots
    """
    time_stamps, ppg_data = load_ppg_from_xdf(filename)
    
    channel_names = ['Green', 'Red', 'IR']
    time_axis = time_stamps - time_stamps[0]  # Relative time in seconds
    
    if plot:
        fig, axs = plt.subplots(3, 2, figsize=(12, 12))
        fig.suptitle('PPG Analysis for All Channels')
    
    for ch, name in enumerate(channel_names):
        ppg_signal = ppg_data[:, ch]
        print(f"\nAnalyzing {name} channel.")
        
        # Apply bandpass filter
        filtered_ppg = bandpass_filter(ppg_signal, fs=100)
        
        # Estimate heart rate
        hr, peaks = estimate_heart_rate(filtered_ppg, fs=100)
        if hr is not None:
            print(f"Estimated average heart rate: {hr:.2f} BPM")
        else:
            print("Could not estimate heart rate (insufficient peaks detected).")
        
        if plot:
            # Plot raw
            axs[ch, 0].plot(time_axis, ppg_signal, label='Raw PPG')
            axs[ch, 0].set_title(f'Raw PPG ({name})')
            axs[ch, 0].set_xlabel('Time (s)')
            axs[ch, 0].set_ylabel('Amplitude (raw)')
            axs[ch, 0].legend()
            
            # Plot filtered with peaks
            axs[ch, 1].plot(time_axis, filtered_ppg, label='Filtered PPG')
            if peaks is not None:
                axs[ch, 1].plot(time_axis[peaks], filtered_ppg[peaks], 'ro', label='Detected Peaks')
            axs[ch, 1].set_title(f'Filtered PPG with Peaks ({name})')
            axs[ch, 1].set_xlabel('Time (s)')
            axs[ch, 1].set_ylabel('Amplitude')
            axs[ch, 1].legend()
    
    if plot:
        plt.tight_layout()
        plt.show()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python analyze_ppg_xdf.py <path_to_xdf_file>")
        sys.exit(1)
    
    filename = sys.argv[1]
    analyze_ppg(filename, plot=True)